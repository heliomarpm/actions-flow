name: CD - Pull Request

on:
  workflow_call:
    inputs:
      main_branch:
        description: 'Main branch (default: main)'
        required: false
        type: string
        default: "main"
      develop_branch:
        description: 'Develop branch (default: develop)'
        required: false
        type: string
        default: "develop"

    secrets:
      GH_TOKEN:
        required: true

permissions:
  contents: write
  pull-requests: write

jobs:
  resolve-branch:
    runs-on: ubuntu-latest
    outputs:
      head: ${{ steps.resolve.outputs.head }}
      base: ${{ steps.resolve.outputs.base }}
      skip: ${{ steps.resolve.outputs.skip }}

    steps:
    - name: üîç Resolve branches
      id: resolve
      run: |
        HEAD="${{ github.event.workflow_run.head_branch || github.head_ref || github.ref_name }}"
        MAIN="${{ inputs.main_branch }}"
        DEV="${{ inputs.develop_branch }}"
        REL_PREFIX="${{ inputs.prefix_release_branch }}"

        if [[ "$HEAD" == "$MAIN" ]]; then
          echo "skip=true" >> $GITHUB_OUTPUT
          exit 0
        fi

        if [[ "$HEAD" == "$DEV" ]]; then
          BASE="$MAIN"
        else
          BASE="$DEV"
        fi

        echo "üîπ Pull Request: $HEAD ‚Üí $BASE"

        echo "base=$BASE" >> $GITHUB_OUTPUT
        echo "head=$HEAD" >> $GITHUB_OUTPUT
        echo "skip=false" >> $GITHUB_OUTPUT

    - name: üö´ Skip - main branch detected
      if: steps.resolve.outputs.skip == 'true'
      run: echo "‚Üí Main branch detected. Skipping auto PR."

  read-quality:
    needs: resolve-branch
    if: needs.resolve-branch.outputs.skip != 'true'
    runs-on: ubuntu-latest

    outputs:
      status: ${{ steps.quality.outputs.status }}
      base: ${{ steps.quality.outputs.base }}
      line: ${{ steps.quality.outputs.line }}
      min: ${{ steps.quality.outputs.min }}
      delta: ${{ steps.quality.outputs.delta }}
      mode: ${{ steps.quality.outputs.mode }}
      reason: ${{ steps.quality.outputs.reason }}

    steps:
    - name: üîé Read quality check
      id: quality
      uses: actions/github-script@v7
      with:
        github-token: ${{ secrets.GH_TOKEN }}
        script: |
          const { owner, repo } = context.repo;
          const sha = context.payload.workflow_run.head_sha;

          const checks = await github.rest.checks.listForRef({
            owner,
            repo,
            ref: sha
          });

          const check = checks.data.check_runs.find(c => c.name === "actions-flow/quality");

          if (!check) {
            core.setOutput("status", "missing");
            return;
          }

          const json = check.output.text.match(/```json\n([\s\S]*)\n```/)[1];
          const data = JSON.parse(json);

          core.setOutput("line", data.coverage.line);
          core.setOutput("base", data.coverage.base);
          core.setOutput("delta", data.coverage.delta);
          core.setOutput("min", data.coverage.minimum);
          core.setOutput("mode", data.coverage.mode);
          core.setOutput("status", data.coverage.status);
          core.setOutput("reason", data.coverage.reason);

          console.log("üìä Coverage: ", data.coverage);

    # read-coverage:
    #   needs: resolve-branch
    #   if: needs.resolve-branch.outputs.skip != 'true'
    #   runs-on: ubuntu-latest

    #   env:
    #     REUSABLE_PATH: ${{ github.workspace }}/__reusable_flow__
    #     BASH_ENV: ${{ github.workspace }}/__reusable_flow__/scripts/shared/shell-helpers.sh

    #   # outputs:
    #   #   line: ${{ steps.coverage.outputs.line }}
    #   #   status: ${{ steps.eval-coverage.outputs.status }}

    #   outputs:
    #     line: ${{ steps.coverage.outputs.line }}
    #     status: ${{ steps.coverage.outputs.status }}
    #     min: ${{ steps.coverage.outputs.min }}
    #     mode: ${{ steps.coverage.outputs.mode }}

    #   steps:
    #   - name: üì• Download coverage artifact
    #     uses: actions/download-artifact@v4
    #     continue-on-error: true
    #     with:
    #       pattern: coverage-*
    #       path: ${{ github.workspace }}/coverage
    #       merge-multiple: true

    #   - name: üìä Read coverage report
    #     id: coverage
    #     run: |
    #       FILE=$(find coverage -name coverage-summary.normalized.json | head -n 1)

    #       if [ -z "$FILE" ]; then
    #         echo "base=0" >> $GITHUB_OUTPUT
    #         echo "line=0" >> $GITHUB_OUTPUT
    #         echo "delta=‚ûñ" >> $GITHUB_OUTPUT
    #         echo "min=0" >> $GITHUB_OUTPUT
    #         echo "status=missing" >> $GITHUB_OUTPUT
    #         echo "mode=info" >> $GITHUB_OUTPUT
    #         echo "reason=not-found" >> $GITHUB_OUTPUT
    #         exit 0
    #       fi

    #       BASE_LINE=$(jq '.base' "$FILE")
    #       LINE=$(jq '.line' "$FILE")
    #       DELTA=$(jq -r '.delta' "$FILE")
    #       MIN=$(jq '.min' "$FILE")
    #       STATUS=$(jq -r '.status' "$FILE")
    #       MODE=$(jq -r '.mode' "$FILE")
    #       REASON=$(jq -r '.reason' "$FILE")

    #       echo "base=$BASE_LINE" >> $GITHUB_OUTPUT
    #       echo "line=$LINE" >> $GITHUB_OUTPUT
    #       echo "delta=$DELTA" >> $GITHUB_OUTPUT
    #       echo "min=$MIN" >> $GITHUB_OUTPUT
    #       echo "status=$STATUS" >> $GITHUB_OUTPUT
    #       echo "mode=$MODE" >> $GITHUB_OUTPUT
    #       echo "reason=$REASON" >> $GITHUB_OUTPUT

    # - name: ‚úÖ Evaluate coverage
    #   id: eval-coverage
    #   run: |
    #     REPORT="${{ steps.coverage.outputs.report }}"
    #     LINE=${{ steps.coverage.outputs.line || 0 }}
    #     MIN=${{ inputs.coverage_min || 0 }}
    #     MODE="${{ inputs.coverage_mode }}"

    #     echo "‚Üí Minimum coverage: $MIN%"
    #     echo "‚Üí Coverage mode: $MODE"

    #     FINAL_STATUS="passed"

    #     if [ "$REPORT" = "not-found" ]; then
    #       FINAL_STATUS="missing"
    #       echo "‚ö†Ô∏è No tests or coverage detected"

    #       if [ "$MODE" = "block" ]; then
    #         fail "‚ùå Blocking PR: tests not implemented"
    #       fi
    #     elif [ "$LINE" -lt "$MIN" ]; then
    #       FINAL_STATUS="failed"
    #       MSG="‚ùå Coverage below threshold ($LINE < $MIN)"

    #       if [ "$MODE" = "block" ]; then
    #         fail "$MSG"
    #       fi

    #       echo "$MSG"
    #     fi

    #     echo "status=$FINAL_STATUS" >> $GITHUB_OUTPUT

  auto-pr:
    needs:
    - resolve-branch
    - read-quality
    if: needs.resolve-branch.outputs.skip != 'true'
    runs-on: ubuntu-latest

    env:
      REUSABLE_PATH: ${{ github.workspace }}/__reusable_flow__
      BASH_ENV: ${{ github.workspace }}/__reusable_flow__/scripts/shared/shell-helpers.sh

    steps:
    - name: üìå Checkout consumer repository
      uses: actions/checkout@v4
      with:
        fetch-depth: 0 # Necess√°rio para evitar falhas do gh CLI em reposit√≥rios grandes
        token: ${{ secrets.GH_TOKEN }} # Necess√°rio se o reposit√≥rio for privado

    - name: üìå Checkout reusable repository
      uses: actions/checkout@v4
      with:
        repository: heliomarpm/actions-flow
        ref: main # ${{ github.ref }}
        path: ${{ env.REUSABLE_PATH }}

    - name: üîê Auth GitHub CLI
      run: |
        # echo "${GITHUB_TOKEN}" | gh auth login --with-token
        gh auth setup-git
      env:
        GITHUB_TOKEN: ${{ secrets.GH_TOKEN }}

    - name: üîé Ensure Destination Branch
      if: needs.resolve-branch.outputs.skip != 'true'
      run: |
        BASE="${{ needs.resolve-branch.outputs.base }}"

        if ! git ls-remote --exit-code --heads origin "$BASE" > /dev/null 2>&1; then
          {
            echo "## ‚ùå Invalid destination branch"
            echo ""
            echo "Branch `$BASE` does not exist."
            echo ""
            echo "### Available branches:"
            git ls-remote --heads origin | awk '{print $2}' | sed 's|refs/heads/||'
          } >> "$GITHUB_STEP_SUMMARY"

          echo "Expected branch: $BASE"
          exit 1
        fi

    - name: üè∑ Ensure auto-generated label exists
      if: needs.resolve-branch.outputs.skip != 'true'
      run: |
        ensure_label "auto-generated" "Pull Request criada automaticamente" 006B75
        ensure_label "coverage-failed" "Cobertura de testes abaixo do limite m√≠nimo" D93F0B
        ensure_label "coverage-passed" "Cobertura de testes adequado" 0E8A16
        ensure_label "coverage-missing" "Sem testes ou cobertura de testes" E99695

        # gh label create auto-generated --description "Pull Request criada automaticamente" --color 006B75 || true
        # gh label create "coverage-failed" --description "Cobertura de testes abaixo do limite m√≠nimo." --color "D93F0B" || true
        # gh label create "coverage-passed" --description "Cobertura de testes acima do limite m√≠nimo." --color "0E8A16" || true
        # gh label create "coverage-missing" --description "Cobertura de testes n√£o encontrada." --color "E99695" || true

      env:
        GITHUB_TOKEN: ${{ secrets.GH_TOKEN }}

    - name: üìù Generate PR body
      if: needs.resolve-branch.outputs.skip != 'true'
      run: |
        COV_BASE="${{ needs.read-quality.outputs.base }}"
        COV_LINE="${{ needs.read-quality.outputs.line }}"
        COV_DELTA="${{ needs.read-quality.outputs.delta }}"
        COV_MIN="${{ needs.read-quality.outputs.min }}"
        COV_STATUS="${{ needs.read-quality.outputs.status }}"
        COV_MODE="${{ needs.read-quality.outputs.mode }}"
        COV_REASON="${{ needs.read-quality.outputs.reason }}"

        echo "COV_BASE=$COV_BASE"
        echo "COV_LINE=$COV_LINE"
        echo "COV_DELTA=$COV_DELTA"
        echo "COV_MIN=$COV_MIN"
        echo "COV_STATUS=$COV_STATUS"
        echo "COV_MODE=$COV_MODE"
        echo "COV_REASON=$COV_REASON"

        TITLE="üìä Cobertura de Testes"

        if [ "$COV_STATUS" = "passed" ]; then
          INTERPRETATION="A cobertura est√° **de acordo** com o limite exigido."
        elif [ "$COV_STATUS" = "failed" ]; then
          INTERPRETATION="A cobertura est√° **abaixo** do limite m√≠nimo. Adicione testes antes de mesclar." 
        else
          INTERPRETATION="Nenhum teste ou relat√≥rio de cobertura foi detectado nesta execu√ß√£o." 
        fi

        if [ -n "$COV_LINE" ]; then
          COVERAGE_BLOCK=$(cat <<EOF
        ### $TITLE

        | M√©trica | Valor  |
        |-------- |------- |
        | Branch Base  | **$COV_BASE%** |
        | Linhas  | **$COV_LINE%** |
        | Delta  | $COV_DELTA |
        | M√≠nimo requerido | $COV_MIN% |
        | Modo | \`$COV_MODE\` |
        | Status | **$COV_STATUS** |

        EOF
        )

        else
          COVERAGE_BLOCK=$(cat <<EOF
        ### $TITLE

        ‚ö†Ô∏è Cobertura n√£o gerada para este projeto.
        EOF
        )
        fi

        cat <<EOF > pr_body.md

        ## ü§ñ Pull Request Autom√°tica

        Esta PR foi criada ou atualizada automaticamente.

        **Origem:** \`${{ needs.resolve-branch.outputs.head }}\`  
        **Destino:** \`${{ needs.resolve-branch.outputs.base }}\`

        ---

        ${COVERAGE_BLOCK}          

        $INTERPRETATION
        ---
        _Gerado automaticamente pela action **auto-pr**_
        EOF

    - name: üìú Create or Update Pull Request
      id: create-pr
      run: |
        HEAD="${{ needs.resolve-branch.outputs.head }}"
        BASE="${{ needs.resolve-branch.outputs.base }}"
        TITLE="üîÄ PR ($(date +'%Y-%m-%d')): ${HEAD} ‚Üí ${BASE}"
        STATUS_COVERAGE="${{ needs.read-quality.outputs.status }}"

        if [ "$STATUS_COVERAGE" = "failed" ]; then
          ADD_LABEL="coverage-failed"
          DEL_LABEL="coverage-passed,coverage-missing"
        elif [ "$STATUS_COVERAGE" = "passed" ]; then
          ADD_LABEL="coverage-passed"
          DEL_LABEL="coverage-failed,coverage-missing"
        elif [ "$STATUS_COVERAGE" = "missing" ]; then
          ADD_LABEL="coverage-missing"
          DEL_LABEL="coverage-passed,coverage-failed"
        fi

        # Tenta encontrar um PR existente
        PR_NUMBER=$(gh pr list --base "$BASE" --head "$HEAD" --json number --jq '.[0].number')

        echo "$TITLE"

        if [ -z "$PR_NUMBER" ]; then
          echo "‚Üí No existing PR found. Creating new PR..."
          gh pr create \
            --base "$BASE" \
            --head "$HEAD" \
            --title "$TITLE" \
            --body-file pr_body.md \
            --label "auto-generated,$ADD_LABEL" \
            --assignee "${{ github.actor }}"

          # Fetch PR URL after creation
          PR_URL=$(gh pr view "$HEAD" --json url --jq '.url')
          PR_ACTION="created"
        else
          echo "‚Üí Existing PR #$PR_NUMBER found. Updating..."
          gh pr edit "$PR_NUMBER" \
            --title "$TITLE" \
            --body-file pr_body.md \
            --add-assignee "${{ github.actor }}" \
            --remove-label "$DEL_LABEL" \
            --add-label "$ADD_LABEL"

          PR_URL="https://github.com/${{ github.repository }}/pull/$PR_NUMBER"
          PR_ACTION="updated"
        fi

        echo "::notice title=Auto PR ${PR_ACTION}::${HEAD} ‚Üí ${BASE}"
        echo "::notice title=Pull Request::${PR_URL}"

        echo "pr_url=${PR_URL}" >> $GITHUB_OUTPUT
        echo "pr_action=${PR_ACTION}" >> $GITHUB_OUTPUT
      env:
        GITHUB_TOKEN: ${{ secrets.GH_TOKEN }}

    - name: üßæ Job Summary
      if: always()
      run: |
        cat <<EOF >> $GITHUB_STEP_SUMMARY
        ## üîÄ Auto Pull Request

        **Status:** \`${{ steps.create-pr.outputs.pr_action || 'processed' }}\`

        **From:** \`${{ needs.resolve-branch.outputs.head }}\`  
        **To:** \`${{ needs.resolve-branch.outputs.base }}\`

        **Coverage:** \`${{ needs.read-quality.outputs.status }}\`
        
        | Metric      | Value                                       |
        |------------ |-------------------------------------------- |
        | Base Branch | ${{ needs.read-quality.outputs.base }}%     |
        | Coverage    | **${{ needs.read-quality.outputs.line }}%** |
        | Delta Œî     | ${{ needs.read-quality.outputs.delta }}     |
        | Minimum     | ${{ needs.read-quality.outputs.min }}%      |
        | Mode        | \`${{ needs.read-quality.outputs.mode }}\`  |
        | Status      | \`${{ needs.read-quality.outputs.status }}\`|
        
        if [ -n "${{ needs.read-quality.outputs.reason }}" ]; then
          **Reason:** ${{ needs.read-quality.outputs.reason }}
        fi

        üîó **PR:** ${{ steps.create-pr.outputs.pr_url || '<failed>' }}

        ---
        _Gerado automaticamente pela action **auto-pr**_
        EOF
